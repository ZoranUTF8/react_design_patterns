Container-Presentational Pattern
In React one way to enforce separation of concerns is by using this pattern.
By using it we can separate the VIEW from the application logic

Example:
Separate the app into two parts:

Part1: Presentational Components: Components that care about how data is shown to the user. Rendering a list of dog images
        is the app view. This type of components receive the data and simply display the data without modification to 
        the same data. Presentational components are usually stateless meaning that they do not contain their own
        react state UNLESS they need a state for UI purposes.

        import React from "react";

        // ? Presentational Component
            const DisplayDogImages = ({ dogsImagesData }) => {
                 return dogsImagesData.map((dog) => (
                 <img src={dog.src} key={dog.id} alt="Dog image" />
                ));
                };

            export default DisplayDogImages;


Part2: Container Components: Components that care about what data is shown to the user. Fetching dog images data is
        the application logic. The main function of the container components is to fetch the data and pass it on 
        to the Presentational components that they render.

    import React, { useState, useEffect } from "react";
import DisplayDogImages from "./DisplayDogImages";

const DisplayDogImagesContainer = () => {
  const [dogsData, setDogsData] = useState([]);

  useEffect(() => {
    fetch("https://dog.ceo/api/breed/labrador/images/random/6")
      .then((res) => res.json())
      .then(({ message }) => {
        console.log(`Message is:  ${message}`), setDogsData(message);
      })
      .catch((err) => {
        console.log(`Error fetching images: ${err}`);
      });
  }, []);

  if (dogsData.length < 1) return <h1>Loading data...</h1>;

  return (
    <div>
      DisplayDogImagesContainer
      <DisplayDogImages dogsImagesData={dogsData} />
    </div>
  );
};

export default DisplayDogImagesContainer;


Using this approach helps us to separate the application logic and the view.


With the introduction of react hooks we can create a custom hook that fetches the images and returen the array of the results.
Using the hook makes it easy to separte the logic and view but it saves us the EXTRA LAYER that  we have with the Container
component which was wrapping the Presentational component before.

OBSERVER
Good for implementing a flexible and decoupled communication mechanism between components.
Use observables to notify subscribers when an event occurs

An observable object, which can be observed by subscribers in order to notify them.
Subscribers, which can subscribe to and get notified by the observable object.

Decreased performance: Notifying all subscribers might take a significant amount of time if the observer handling becomes too complex, or if there are too many subscibers to notify.
Separation of Concerns: The observer objects aren't tightly coupled to the observable object, and can be (de)coupled at any time. The observable object is responsible for monitoring the events, while the observers simply handle the received data.


PROXY 
Pros:
Control: Proxies make it easy to add functionality when interacting with a certain object, such as validation, logging, formatting, notifications, debugging.
Cons:
Long handler execution: Executing handlers on every object interaction could lead to performance issues.

Usage:
Notifications, Logging, Validation, Formatting.


Factory Pattern
Use a factory function in order to create objects
With the Factory Pattern, we can use a special function - the factory function - to create many of the same objects.
Pro:
The factory pattern is useful when we have to create multiple objects that share the same properties, without having to repeat the same code over and over. A factory function can easily return a custom object depending on the current environment, or user-specific configuration.
Con:
In JavaScript, the factory pattern isn't much more than a function that returns an object without using the new keyword.
Not very memory efficient


Prototype Pattern
If we want to share properties among many objects of the same type, we can use the Prototype pattern.

Memory efficient: The prototype chain allows us to access properties that aren't directly defined on the object itself, we can avoid duplication of methods and properties, thus reducing the amount of memory used.

Readaibility: When a class has been extended many times, it can be difficult to know where certain properties come from.

Container/Presentational Pattern
Enforce separation of concerns by separating the view from the application logic.

Presentational Component, that cares about how data is shown to the user.
Container Component, that cares about what data is shown to the user.


Higher-Order Components
Higher-Order Components (HOC) make it easy to pass logic to components by wrapping them.

Separation of concerns: Using the Higher-Order Component pattern allows us to keep logic that we want to re-use all in one place. This reduces the risk of accidentally spreading bugs throughout the application by duplicating code over and over, potentially introducing new bugs each time

Naming collisions: It can easily happen that the HOC overrides a prop of a component. Make sure that the HOC can handle accidental name collision, by either renaming the prop or merging the props.

Readability: When using multiple composed HOCs that all pass props to the element that's wrapped within them, it can be difficult to figure out which HOC is responsible for which prop. This can hinder debugging and scaling an application easily.

Render Props Pattern

Pass JSX elements to components through props

With the Render Props pattern, we pass components as props to other components. The components that are passed as props can in turn receive props from that component.
Tradeoffs
Reusability: Since render props can be different each time, we can make components that receive render props highly reusable for multiple usecases.

Separation of concerns: We can separate our app's logic from rendering components through render props. The stateful component that receives a render prop can pass the data onto stateless components, which merely render the data.

Solution to HOC problems: Since we explicitly pass props, we solve the HOC's implicit props issue. The props that should get passed down to the element, are all visible in the render prop's arguments list. We know exactly where certain props come from.

Unnecessary with Hooks: Hooks changed the way we can add reusability and data sharing to components, which can replace the render props pattern in many cases.


Hooks Pattern
Use functions to reuse stateful logic among multiple components throughout the app

Overview
React Hooks are functions special types of functions that you can use in order to:

Add state to a functional component
Reuse stateful logic among multiple components throughout the app.
Manage a component's lifecycle
Besides built-in hooks, such as useState, useEffect, and useReducer, we can create custom hooks to easiliy share stateful logic across multiple components within the application.

