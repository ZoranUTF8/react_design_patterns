Container-Presentational Pattern
In React one way to enforce separation of concerns is by using this pattern.
By using it we can separate the VIEW from the application logic

Example:
Separate the app into two parts:

Part1: Presentational Components: Components that care about how data is shown to the user. Rendering a list of dog images
        is the app view. This type of components receive the data and simply display the data without modification to 
        the same data. Presentational components are usually stateless meaning that they do not contain their own
        react state UNLESS they need a state for UI purposes.

        import React from "react";

        // ? Presentational Component
            const DisplayDogImages = ({ dogsImagesData }) => {
                 return dogsImagesData.map((dog) => (
                 <img src={dog.src} key={dog.id} alt="Dog image" />
                ));
                };

            export default DisplayDogImages;


Part2: Container Components: Components that care about what data is shown to the user. Fetching dog images data is
        the application logic. The main function of the container components is to fetch the data and pass it on 
        to the Presentational components that they render.

    import React, { useState, useEffect } from "react";
import DisplayDogImages from "./DisplayDogImages";

const DisplayDogImagesContainer = () => {
  const [dogsData, setDogsData] = useState([]);

  useEffect(() => {
    fetch("https://dog.ceo/api/breed/labrador/images/random/6")
      .then((res) => res.json())
      .then(({ message }) => {
        console.log(`Message is:  ${message}`), setDogsData(message);
      })
      .catch((err) => {
        console.log(`Error fetching images: ${err}`);
      });
  }, []);

  if (dogsData.length < 1) return <h1>Loading data...</h1>;

  return (
    <div>
      DisplayDogImagesContainer
      <DisplayDogImages dogsImagesData={dogsData} />
    </div>
  );
};

export default DisplayDogImagesContainer;


Using this approach helps us to separate the application logic and the view.


With the introduction of react hooks we can create a custom hook that fetches the images and returen the array of the results.
Using the hook makes it easy to separte the logic and view but it saves us the EXTRA LAYER that  we have with the Container
component which was wrapping the Presentational component before.

OBSERVER
Good for implementing a flexible and decoupled communication mechanism between components.
Use observables to notify subscribers when an event occurs

An observable object, which can be observed by subscribers in order to notify them.
Subscribers, which can subscribe to and get notified by the observable object.

Decreased performance: Notifying all subscribers might take a significant amount of time if the observer handling becomes too complex, or if there are too many subscibers to notify.
Separation of Concerns: The observer objects aren't tightly coupled to the observable object, and can be (de)coupled at any time. The observable object is responsible for monitoring the events, while the observers simply handle the received data.


PROXY 
Pros:
Control: Proxies make it easy to add functionality when interacting with a certain object, such as validation, logging, formatting, notifications, debugging.
Cons:
Long handler execution: Executing handlers on every object interaction could lead to performance issues.

Usage:
Notifications, Logging, Validation, Formatting.


Factory Pattern
Use a factory function in order to create objects
With the Factory Pattern, we can use a special function - the factory function - to create many of the same objects.
Pro:
The factory pattern is useful when we have to create multiple objects that share the same properties, without having to repeat the same code over and over. A factory function can easily return a custom object depending on the current environment, or user-specific configuration.
Con:
In JavaScript, the factory pattern isn't much more than a function that returns an object without using the new keyword.
Not very memory efficient


Prototype Pattern
If we want to share properties among many objects of the same type, we can use the Prototype pattern.

Memory efficient: The prototype chain allows us to access properties that aren't directly defined on the object itself, we can avoid duplication of methods and properties, thus reducing the amount of memory used.

Readaibility: When a class has been extended many times, it can be difficult to know where certain properties come from.